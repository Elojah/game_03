/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.6.1
 * source: github.com/elojah/game_03/pkg/ability/ability.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./../../../../gogo/protobuf/gogoproto/gogo";
import * as dependency_2 from "./../entity/entity";
import * as pb_1 from "google-protobuf";
export namespace ability {
    export enum TargetType {
        NoneTarget = 0,
        Self = 1,
        Foe = 2,
        Ally = 3,
        Spawn = 4,
        Rect = 5,
        Circle = 6
    }
    export enum Move {
        NoneMove = 0,
        Walk = 1,
        Teleport = 2,
        Push = 3
    }
    export enum Operator {
        NoneOperator = 0,
        Equal = 1,
        NotEqual = 2,
        Greater = 3,
        Lesser = 4
    }
    export class MoveTarget extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            Move?: Move;
            TargetType?: TargetType;
            TargetID?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Move" in data && data.Move != undefined) {
                    this.Move = data.Move;
                }
                if ("TargetType" in data && data.TargetType != undefined) {
                    this.TargetType = data.TargetType;
                }
                if ("TargetID" in data && data.TargetID != undefined) {
                    this.TargetID = data.TargetID;
                }
            }
        }
        get Move() {
            return pb_1.Message.getFieldWithDefault(this, 1, Move.NoneMove) as Move;
        }
        set Move(value: Move) {
            pb_1.Message.setField(this, 1, value);
        }
        get TargetType() {
            return pb_1.Message.getFieldWithDefault(this, 2, TargetType.NoneTarget) as TargetType;
        }
        set TargetType(value: TargetType) {
            pb_1.Message.setField(this, 2, value);
        }
        get TargetID() {
            return pb_1.Message.getFieldWithDefault(this, 3, new Uint8Array(0)) as Uint8Array;
        }
        set TargetID(value: Uint8Array) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            Move?: Move;
            TargetType?: TargetType;
            TargetID?: Uint8Array;
        }): MoveTarget {
            const message = new MoveTarget({});
            if (data.Move != null) {
                message.Move = data.Move;
            }
            if (data.TargetType != null) {
                message.TargetType = data.TargetType;
            }
            if (data.TargetID != null) {
                message.TargetID = data.TargetID;
            }
            return message;
        }
        toObject() {
            const data: {
                Move?: Move;
                TargetType?: TargetType;
                TargetID?: Uint8Array;
            } = {};
            if (this.Move != null) {
                data.Move = this.Move;
            }
            if (this.TargetType != null) {
                data.TargetType = this.TargetType;
            }
            if (this.TargetID != null) {
                data.TargetID = this.TargetID;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Move != Move.NoneMove)
                writer.writeEnum(1, this.Move);
            if (this.TargetType != TargetType.NoneTarget)
                writer.writeEnum(2, this.TargetType);
            if (this.TargetID.length)
                writer.writeBytes(3, this.TargetID);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MoveTarget {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MoveTarget();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.Move = reader.readEnum();
                        break;
                    case 2:
                        message.TargetType = reader.readEnum();
                        break;
                    case 3:
                        message.TargetID = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MoveTarget {
            return MoveTarget.deserialize(bytes);
        }
    }
    export class Target extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            Type?: TargetType;
            GroupID?: Uint8Array;
            Closest?: boolean;
            Range?: number;
            Radius?: number;
            Width?: number;
            Height?: number;
            MoveTarget?: MoveTarget;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Type" in data && data.Type != undefined) {
                    this.Type = data.Type;
                }
                if ("GroupID" in data && data.GroupID != undefined) {
                    this.GroupID = data.GroupID;
                }
                if ("Closest" in data && data.Closest != undefined) {
                    this.Closest = data.Closest;
                }
                if ("Range" in data && data.Range != undefined) {
                    this.Range = data.Range;
                }
                if ("Radius" in data && data.Radius != undefined) {
                    this.Radius = data.Radius;
                }
                if ("Width" in data && data.Width != undefined) {
                    this.Width = data.Width;
                }
                if ("Height" in data && data.Height != undefined) {
                    this.Height = data.Height;
                }
                if ("MoveTarget" in data && data.MoveTarget != undefined) {
                    this.MoveTarget = data.MoveTarget;
                }
            }
        }
        get Type() {
            return pb_1.Message.getFieldWithDefault(this, 1, TargetType.NoneTarget) as TargetType;
        }
        set Type(value: TargetType) {
            pb_1.Message.setField(this, 1, value);
        }
        get GroupID() {
            return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array;
        }
        set GroupID(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        get Closest() {
            return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
        }
        set Closest(value: boolean) {
            pb_1.Message.setField(this, 3, value);
        }
        get Range() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set Range(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get Radius() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set Radius(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get Width() {
            return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
        }
        set Width(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        get Height() {
            return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
        }
        set Height(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        get MoveTarget() {
            return pb_1.Message.getWrapperField(this, MoveTarget, 8) as MoveTarget;
        }
        set MoveTarget(value: MoveTarget) {
            pb_1.Message.setWrapperField(this, 8, value);
        }
        get has_MoveTarget() {
            return pb_1.Message.getField(this, 8) != null;
        }
        static fromObject(data: {
            Type?: TargetType;
            GroupID?: Uint8Array;
            Closest?: boolean;
            Range?: number;
            Radius?: number;
            Width?: number;
            Height?: number;
            MoveTarget?: ReturnType<typeof MoveTarget.prototype.toObject>;
        }): Target {
            const message = new Target({});
            if (data.Type != null) {
                message.Type = data.Type;
            }
            if (data.GroupID != null) {
                message.GroupID = data.GroupID;
            }
            if (data.Closest != null) {
                message.Closest = data.Closest;
            }
            if (data.Range != null) {
                message.Range = data.Range;
            }
            if (data.Radius != null) {
                message.Radius = data.Radius;
            }
            if (data.Width != null) {
                message.Width = data.Width;
            }
            if (data.Height != null) {
                message.Height = data.Height;
            }
            if (data.MoveTarget != null) {
                message.MoveTarget = MoveTarget.fromObject(data.MoveTarget);
            }
            return message;
        }
        toObject() {
            const data: {
                Type?: TargetType;
                GroupID?: Uint8Array;
                Closest?: boolean;
                Range?: number;
                Radius?: number;
                Width?: number;
                Height?: number;
                MoveTarget?: ReturnType<typeof MoveTarget.prototype.toObject>;
            } = {};
            if (this.Type != null) {
                data.Type = this.Type;
            }
            if (this.GroupID != null) {
                data.GroupID = this.GroupID;
            }
            if (this.Closest != null) {
                data.Closest = this.Closest;
            }
            if (this.Range != null) {
                data.Range = this.Range;
            }
            if (this.Radius != null) {
                data.Radius = this.Radius;
            }
            if (this.Width != null) {
                data.Width = this.Width;
            }
            if (this.Height != null) {
                data.Height = this.Height;
            }
            if (this.MoveTarget != null) {
                data.MoveTarget = this.MoveTarget.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Type != TargetType.NoneTarget)
                writer.writeEnum(1, this.Type);
            if (this.GroupID.length)
                writer.writeBytes(2, this.GroupID);
            if (this.Closest != false)
                writer.writeBool(3, this.Closest);
            if (this.Range != 0)
                writer.writeInt64(4, this.Range);
            if (this.Radius != 0)
                writer.writeInt64(5, this.Radius);
            if (this.Width != 0)
                writer.writeInt64(6, this.Width);
            if (this.Height != 0)
                writer.writeInt64(7, this.Height);
            if (this.has_MoveTarget)
                writer.writeMessage(8, this.MoveTarget, () => this.MoveTarget.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Target {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Target();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.Type = reader.readEnum();
                        break;
                    case 2:
                        message.GroupID = reader.readBytes();
                        break;
                    case 3:
                        message.Closest = reader.readBool();
                        break;
                    case 4:
                        message.Range = reader.readInt64();
                        break;
                    case 5:
                        message.Radius = reader.readInt64();
                        break;
                    case 6:
                        message.Width = reader.readInt64();
                        break;
                    case 7:
                        message.Height = reader.readInt64();
                        break;
                    case 8:
                        reader.readMessage(message.MoveTarget, () => message.MoveTarget = MoveTarget.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Target {
            return Target.deserialize(bytes);
        }
    }
    export class AbilityModifier extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            Cancel?: boolean;
            CastTime?: number;
            ManaCost?: number;
            Cooldown?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Cancel" in data && data.Cancel != undefined) {
                    this.Cancel = data.Cancel;
                }
                if ("CastTime" in data && data.CastTime != undefined) {
                    this.CastTime = data.CastTime;
                }
                if ("ManaCost" in data && data.ManaCost != undefined) {
                    this.ManaCost = data.ManaCost;
                }
                if ("Cooldown" in data && data.Cooldown != undefined) {
                    this.Cooldown = data.Cooldown;
                }
            }
        }
        get Cancel() {
            return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
        }
        set Cancel(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        get CastTime() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set CastTime(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get ManaCost() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set ManaCost(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get Cooldown() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set Cooldown(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            Cancel?: boolean;
            CastTime?: number;
            ManaCost?: number;
            Cooldown?: number;
        }): AbilityModifier {
            const message = new AbilityModifier({});
            if (data.Cancel != null) {
                message.Cancel = data.Cancel;
            }
            if (data.CastTime != null) {
                message.CastTime = data.CastTime;
            }
            if (data.ManaCost != null) {
                message.ManaCost = data.ManaCost;
            }
            if (data.Cooldown != null) {
                message.Cooldown = data.Cooldown;
            }
            return message;
        }
        toObject() {
            const data: {
                Cancel?: boolean;
                CastTime?: number;
                ManaCost?: number;
                Cooldown?: number;
            } = {};
            if (this.Cancel != null) {
                data.Cancel = this.Cancel;
            }
            if (this.CastTime != null) {
                data.CastTime = this.CastTime;
            }
            if (this.ManaCost != null) {
                data.ManaCost = this.ManaCost;
            }
            if (this.Cooldown != null) {
                data.Cooldown = this.Cooldown;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Cancel != false)
                writer.writeBool(1, this.Cancel);
            if (this.CastTime != 0)
                writer.writeInt64(2, this.CastTime);
            if (this.ManaCost != 0)
                writer.writeInt64(3, this.ManaCost);
            if (this.Cooldown != 0)
                writer.writeInt64(4, this.Cooldown);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AbilityModifier {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AbilityModifier();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.Cancel = reader.readBool();
                        break;
                    case 2:
                        message.CastTime = reader.readInt64();
                        break;
                    case 3:
                        message.ManaCost = reader.readInt64();
                        break;
                    case 4:
                        message.Cooldown = reader.readInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): AbilityModifier {
            return AbilityModifier.deserialize(bytes);
        }
    }
    export class EffectModifier extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            EffectID?: Uint8Array;
            Cancel?: boolean;
            Stat?: dependency_2.entity.Stat;
            Amount?: Amount;
            Duration?: number;
            Delay?: number;
            Repeat?: number;
            StackRules?: StackRules;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("EffectID" in data && data.EffectID != undefined) {
                    this.EffectID = data.EffectID;
                }
                if ("Cancel" in data && data.Cancel != undefined) {
                    this.Cancel = data.Cancel;
                }
                if ("Stat" in data && data.Stat != undefined) {
                    this.Stat = data.Stat;
                }
                if ("Amount" in data && data.Amount != undefined) {
                    this.Amount = data.Amount;
                }
                if ("Duration" in data && data.Duration != undefined) {
                    this.Duration = data.Duration;
                }
                if ("Delay" in data && data.Delay != undefined) {
                    this.Delay = data.Delay;
                }
                if ("Repeat" in data && data.Repeat != undefined) {
                    this.Repeat = data.Repeat;
                }
                if ("StackRules" in data && data.StackRules != undefined) {
                    this.StackRules = data.StackRules;
                }
            }
        }
        get EffectID() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set EffectID(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        get Cancel() {
            return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
        }
        set Cancel(value: boolean) {
            pb_1.Message.setField(this, 2, value);
        }
        get Stat() {
            return pb_1.Message.getFieldWithDefault(this, 3, dependency_2.entity.Stat.NoneStat) as dependency_2.entity.Stat;
        }
        set Stat(value: dependency_2.entity.Stat) {
            pb_1.Message.setField(this, 3, value);
        }
        get Amount() {
            return pb_1.Message.getWrapperField(this, Amount, 4) as Amount;
        }
        set Amount(value: Amount) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get has_Amount() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get Duration() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set Duration(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get Delay() {
            return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
        }
        set Delay(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        get Repeat() {
            return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
        }
        set Repeat(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        get StackRules() {
            return pb_1.Message.getWrapperField(this, StackRules, 8) as StackRules;
        }
        set StackRules(value: StackRules) {
            pb_1.Message.setWrapperField(this, 8, value);
        }
        get has_StackRules() {
            return pb_1.Message.getField(this, 8) != null;
        }
        static fromObject(data: {
            EffectID?: Uint8Array;
            Cancel?: boolean;
            Stat?: dependency_2.entity.Stat;
            Amount?: ReturnType<typeof Amount.prototype.toObject>;
            Duration?: number;
            Delay?: number;
            Repeat?: number;
            StackRules?: ReturnType<typeof StackRules.prototype.toObject>;
        }): EffectModifier {
            const message = new EffectModifier({});
            if (data.EffectID != null) {
                message.EffectID = data.EffectID;
            }
            if (data.Cancel != null) {
                message.Cancel = data.Cancel;
            }
            if (data.Stat != null) {
                message.Stat = data.Stat;
            }
            if (data.Amount != null) {
                message.Amount = Amount.fromObject(data.Amount);
            }
            if (data.Duration != null) {
                message.Duration = data.Duration;
            }
            if (data.Delay != null) {
                message.Delay = data.Delay;
            }
            if (data.Repeat != null) {
                message.Repeat = data.Repeat;
            }
            if (data.StackRules != null) {
                message.StackRules = StackRules.fromObject(data.StackRules);
            }
            return message;
        }
        toObject() {
            const data: {
                EffectID?: Uint8Array;
                Cancel?: boolean;
                Stat?: dependency_2.entity.Stat;
                Amount?: ReturnType<typeof Amount.prototype.toObject>;
                Duration?: number;
                Delay?: number;
                Repeat?: number;
                StackRules?: ReturnType<typeof StackRules.prototype.toObject>;
            } = {};
            if (this.EffectID != null) {
                data.EffectID = this.EffectID;
            }
            if (this.Cancel != null) {
                data.Cancel = this.Cancel;
            }
            if (this.Stat != null) {
                data.Stat = this.Stat;
            }
            if (this.Amount != null) {
                data.Amount = this.Amount.toObject();
            }
            if (this.Duration != null) {
                data.Duration = this.Duration;
            }
            if (this.Delay != null) {
                data.Delay = this.Delay;
            }
            if (this.Repeat != null) {
                data.Repeat = this.Repeat;
            }
            if (this.StackRules != null) {
                data.StackRules = this.StackRules.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.EffectID.length)
                writer.writeBytes(1, this.EffectID);
            if (this.Cancel != false)
                writer.writeBool(2, this.Cancel);
            if (this.Stat != dependency_2.entity.Stat.NoneStat)
                writer.writeEnum(3, this.Stat);
            if (this.has_Amount)
                writer.writeMessage(4, this.Amount, () => this.Amount.serialize(writer));
            if (this.Duration != 0)
                writer.writeInt64(5, this.Duration);
            if (this.Delay != 0)
                writer.writeInt64(6, this.Delay);
            if (this.Repeat != 0)
                writer.writeInt64(7, this.Repeat);
            if (this.has_StackRules)
                writer.writeMessage(8, this.StackRules, () => this.StackRules.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EffectModifier {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EffectModifier();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.EffectID = reader.readBytes();
                        break;
                    case 2:
                        message.Cancel = reader.readBool();
                        break;
                    case 3:
                        message.Stat = reader.readEnum();
                        break;
                    case 4:
                        reader.readMessage(message.Amount, () => message.Amount = Amount.deserialize(reader));
                        break;
                    case 5:
                        message.Duration = reader.readInt64();
                        break;
                    case 6:
                        message.Delay = reader.readInt64();
                        break;
                    case 7:
                        message.Repeat = reader.readInt64();
                        break;
                    case 8:
                        reader.readMessage(message.StackRules, () => message.StackRules = StackRules.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): EffectModifier {
            return EffectModifier.deserialize(bytes);
        }
    }
    export class Amount extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            ID?: Uint8Array;
            Direct?: number;
            Target?: Target;
            Stat?: dependency_2.entity.Stat;
            Percentage?: number;
            EffectID?: Uint8Array;
            StatOutcome?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("ID" in data && data.ID != undefined) {
                    this.ID = data.ID;
                }
                if ("Direct" in data && data.Direct != undefined) {
                    this.Direct = data.Direct;
                }
                if ("Target" in data && data.Target != undefined) {
                    this.Target = data.Target;
                }
                if ("Stat" in data && data.Stat != undefined) {
                    this.Stat = data.Stat;
                }
                if ("Percentage" in data && data.Percentage != undefined) {
                    this.Percentage = data.Percentage;
                }
                if ("EffectID" in data && data.EffectID != undefined) {
                    this.EffectID = data.EffectID;
                }
                if ("StatOutcome" in data && data.StatOutcome != undefined) {
                    this.StatOutcome = data.StatOutcome;
                }
            }
        }
        get ID() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set ID(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        get Direct() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set Direct(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get Target() {
            return pb_1.Message.getWrapperField(this, Target, 3) as Target;
        }
        set Target(value: Target) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_Target() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get Stat() {
            return pb_1.Message.getFieldWithDefault(this, 4, dependency_2.entity.Stat.NoneStat) as dependency_2.entity.Stat;
        }
        set Stat(value: dependency_2.entity.Stat) {
            pb_1.Message.setField(this, 4, value);
        }
        get Percentage() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set Percentage(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get EffectID() {
            return pb_1.Message.getFieldWithDefault(this, 6, new Uint8Array(0)) as Uint8Array;
        }
        set EffectID(value: Uint8Array) {
            pb_1.Message.setField(this, 6, value);
        }
        get StatOutcome() {
            return pb_1.Message.getFieldWithDefault(this, 7, false) as boolean;
        }
        set StatOutcome(value: boolean) {
            pb_1.Message.setField(this, 7, value);
        }
        static fromObject(data: {
            ID?: Uint8Array;
            Direct?: number;
            Target?: ReturnType<typeof Target.prototype.toObject>;
            Stat?: dependency_2.entity.Stat;
            Percentage?: number;
            EffectID?: Uint8Array;
            StatOutcome?: boolean;
        }): Amount {
            const message = new Amount({});
            if (data.ID != null) {
                message.ID = data.ID;
            }
            if (data.Direct != null) {
                message.Direct = data.Direct;
            }
            if (data.Target != null) {
                message.Target = Target.fromObject(data.Target);
            }
            if (data.Stat != null) {
                message.Stat = data.Stat;
            }
            if (data.Percentage != null) {
                message.Percentage = data.Percentage;
            }
            if (data.EffectID != null) {
                message.EffectID = data.EffectID;
            }
            if (data.StatOutcome != null) {
                message.StatOutcome = data.StatOutcome;
            }
            return message;
        }
        toObject() {
            const data: {
                ID?: Uint8Array;
                Direct?: number;
                Target?: ReturnType<typeof Target.prototype.toObject>;
                Stat?: dependency_2.entity.Stat;
                Percentage?: number;
                EffectID?: Uint8Array;
                StatOutcome?: boolean;
            } = {};
            if (this.ID != null) {
                data.ID = this.ID;
            }
            if (this.Direct != null) {
                data.Direct = this.Direct;
            }
            if (this.Target != null) {
                data.Target = this.Target.toObject();
            }
            if (this.Stat != null) {
                data.Stat = this.Stat;
            }
            if (this.Percentage != null) {
                data.Percentage = this.Percentage;
            }
            if (this.EffectID != null) {
                data.EffectID = this.EffectID;
            }
            if (this.StatOutcome != null) {
                data.StatOutcome = this.StatOutcome;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.ID.length)
                writer.writeBytes(1, this.ID);
            if (this.Direct != 0)
                writer.writeInt64(2, this.Direct);
            if (this.has_Target)
                writer.writeMessage(3, this.Target, () => this.Target.serialize(writer));
            if (this.Stat != dependency_2.entity.Stat.NoneStat)
                writer.writeEnum(4, this.Stat);
            if (this.Percentage != 0)
                writer.writeInt64(5, this.Percentage);
            if (this.EffectID.length)
                writer.writeBytes(6, this.EffectID);
            if (this.StatOutcome != false)
                writer.writeBool(7, this.StatOutcome);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Amount {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Amount();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.ID = reader.readBytes();
                        break;
                    case 2:
                        message.Direct = reader.readInt64();
                        break;
                    case 3:
                        reader.readMessage(message.Target, () => message.Target = Target.deserialize(reader));
                        break;
                    case 4:
                        message.Stat = reader.readEnum();
                        break;
                    case 5:
                        message.Percentage = reader.readInt64();
                        break;
                    case 6:
                        message.EffectID = reader.readBytes();
                        break;
                    case 7:
                        message.StatOutcome = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Amount {
            return Amount.deserialize(bytes);
        }
    }
    export class Trigger extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            Operator?: Operator;
            Amount?: Amount;
            Treshold?: Amount;
            AbilityModifiers?: Map<string, AbilityModifier>;
            EffectModifiers?: Map<string, EffectModifier>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Operator" in data && data.Operator != undefined) {
                    this.Operator = data.Operator;
                }
                if ("Amount" in data && data.Amount != undefined) {
                    this.Amount = data.Amount;
                }
                if ("Treshold" in data && data.Treshold != undefined) {
                    this.Treshold = data.Treshold;
                }
                if ("AbilityModifiers" in data && data.AbilityModifiers != undefined) {
                    this.AbilityModifiers = data.AbilityModifiers;
                }
                if ("EffectModifiers" in data && data.EffectModifiers != undefined) {
                    this.EffectModifiers = data.EffectModifiers;
                }
            }
            if (!this.AbilityModifiers)
                this.AbilityModifiers = new Map();
            if (!this.EffectModifiers)
                this.EffectModifiers = new Map();
        }
        get Operator() {
            return pb_1.Message.getFieldWithDefault(this, 1, Operator.NoneOperator) as Operator;
        }
        set Operator(value: Operator) {
            pb_1.Message.setField(this, 1, value);
        }
        get Amount() {
            return pb_1.Message.getWrapperField(this, Amount, 2) as Amount;
        }
        set Amount(value: Amount) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_Amount() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get Treshold() {
            return pb_1.Message.getWrapperField(this, Amount, 3) as Amount;
        }
        set Treshold(value: Amount) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_Treshold() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get AbilityModifiers() {
            return pb_1.Message.getField(this, 4) as any as Map<string, AbilityModifier>;
        }
        set AbilityModifiers(value: Map<string, AbilityModifier>) {
            pb_1.Message.setField(this, 4, value as any);
        }
        get EffectModifiers() {
            return pb_1.Message.getField(this, 5) as any as Map<string, EffectModifier>;
        }
        set EffectModifiers(value: Map<string, EffectModifier>) {
            pb_1.Message.setField(this, 5, value as any);
        }
        static fromObject(data: {
            Operator?: Operator;
            Amount?: ReturnType<typeof Amount.prototype.toObject>;
            Treshold?: ReturnType<typeof Amount.prototype.toObject>;
            AbilityModifiers?: {
                [key: string]: ReturnType<typeof AbilityModifier.prototype.toObject>;
            };
            EffectModifiers?: {
                [key: string]: ReturnType<typeof EffectModifier.prototype.toObject>;
            };
        }): Trigger {
            const message = new Trigger({});
            if (data.Operator != null) {
                message.Operator = data.Operator;
            }
            if (data.Amount != null) {
                message.Amount = Amount.fromObject(data.Amount);
            }
            if (data.Treshold != null) {
                message.Treshold = Amount.fromObject(data.Treshold);
            }
            if (typeof data.AbilityModifiers == "object") {
                message.AbilityModifiers = new Map(Object.entries(data.AbilityModifiers).map(([key, value]) => [key, AbilityModifier.fromObject(value)]));
            }
            if (typeof data.EffectModifiers == "object") {
                message.EffectModifiers = new Map(Object.entries(data.EffectModifiers).map(([key, value]) => [key, EffectModifier.fromObject(value)]));
            }
            return message;
        }
        toObject() {
            const data: {
                Operator?: Operator;
                Amount?: ReturnType<typeof Amount.prototype.toObject>;
                Treshold?: ReturnType<typeof Amount.prototype.toObject>;
                AbilityModifiers?: {
                    [key: string]: ReturnType<typeof AbilityModifier.prototype.toObject>;
                };
                EffectModifiers?: {
                    [key: string]: ReturnType<typeof EffectModifier.prototype.toObject>;
                };
            } = {};
            if (this.Operator != null) {
                data.Operator = this.Operator;
            }
            if (this.Amount != null) {
                data.Amount = this.Amount.toObject();
            }
            if (this.Treshold != null) {
                data.Treshold = this.Treshold.toObject();
            }
            if (this.AbilityModifiers != null) {
                data.AbilityModifiers = (Object.fromEntries)((Array.from)(this.AbilityModifiers).map(([key, value]) => [key, value.toObject()]));
            }
            if (this.EffectModifiers != null) {
                data.EffectModifiers = (Object.fromEntries)((Array.from)(this.EffectModifiers).map(([key, value]) => [key, value.toObject()]));
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Operator != Operator.NoneOperator)
                writer.writeEnum(1, this.Operator);
            if (this.has_Amount)
                writer.writeMessage(2, this.Amount, () => this.Amount.serialize(writer));
            if (this.has_Treshold)
                writer.writeMessage(3, this.Treshold, () => this.Treshold.serialize(writer));
            for (const [key, value] of this.AbilityModifiers) {
                writer.writeMessage(4, this.AbilityModifiers, () => {
                    writer.writeString(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            for (const [key, value] of this.EffectModifiers) {
                writer.writeMessage(5, this.EffectModifiers, () => {
                    writer.writeString(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Trigger {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Trigger();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.Operator = reader.readEnum();
                        break;
                    case 2:
                        reader.readMessage(message.Amount, () => message.Amount = Amount.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.Treshold, () => message.Treshold = Amount.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.AbilityModifiers as any, reader, reader.readString, () => {
                            let value;
                            reader.readMessage(message, () => value = AbilityModifier.deserialize(reader));
                            return value;
                        }));
                        break;
                    case 5:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.EffectModifiers as any, reader, reader.readString, () => {
                            let value;
                            reader.readMessage(message, () => value = EffectModifier.deserialize(reader));
                            return value;
                        }));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Trigger {
            return Trigger.deserialize(bytes);
        }
    }
    export class StackRules extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            Stacks?: number;
            MaxStacks?: number;
            MaxDuration?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Stacks" in data && data.Stacks != undefined) {
                    this.Stacks = data.Stacks;
                }
                if ("MaxStacks" in data && data.MaxStacks != undefined) {
                    this.MaxStacks = data.MaxStacks;
                }
                if ("MaxDuration" in data && data.MaxDuration != undefined) {
                    this.MaxDuration = data.MaxDuration;
                }
            }
        }
        get Stacks() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set Stacks(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get MaxStacks() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set MaxStacks(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get MaxDuration() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set MaxDuration(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            Stacks?: number;
            MaxStacks?: number;
            MaxDuration?: number;
        }): StackRules {
            const message = new StackRules({});
            if (data.Stacks != null) {
                message.Stacks = data.Stacks;
            }
            if (data.MaxStacks != null) {
                message.MaxStacks = data.MaxStacks;
            }
            if (data.MaxDuration != null) {
                message.MaxDuration = data.MaxDuration;
            }
            return message;
        }
        toObject() {
            const data: {
                Stacks?: number;
                MaxStacks?: number;
                MaxDuration?: number;
            } = {};
            if (this.Stacks != null) {
                data.Stacks = this.Stacks;
            }
            if (this.MaxStacks != null) {
                data.MaxStacks = this.MaxStacks;
            }
            if (this.MaxDuration != null) {
                data.MaxDuration = this.MaxDuration;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Stacks != 0)
                writer.writeInt64(1, this.Stacks);
            if (this.MaxStacks != 0)
                writer.writeInt64(2, this.MaxStacks);
            if (this.MaxDuration != 0)
                writer.writeInt64(3, this.MaxDuration);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StackRules {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StackRules();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.Stacks = reader.readInt64();
                        break;
                    case 2:
                        message.MaxStacks = reader.readInt64();
                        break;
                    case 3:
                        message.MaxDuration = reader.readInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StackRules {
            return StackRules.deserialize(bytes);
        }
    }
    export class Effect extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            Stat?: dependency_2.entity.Stat;
            Amount?: Amount;
            Duration?: number;
            Icon?: Uint8Array;
            Delay?: number;
            Repeat?: number;
            StackRules?: StackRules;
            Targets?: Map<string, Target>;
            Triggers?: Map<string, Trigger>;
            Effects?: Map<string, Effect>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Stat" in data && data.Stat != undefined) {
                    this.Stat = data.Stat;
                }
                if ("Amount" in data && data.Amount != undefined) {
                    this.Amount = data.Amount;
                }
                if ("Duration" in data && data.Duration != undefined) {
                    this.Duration = data.Duration;
                }
                if ("Icon" in data && data.Icon != undefined) {
                    this.Icon = data.Icon;
                }
                if ("Delay" in data && data.Delay != undefined) {
                    this.Delay = data.Delay;
                }
                if ("Repeat" in data && data.Repeat != undefined) {
                    this.Repeat = data.Repeat;
                }
                if ("StackRules" in data && data.StackRules != undefined) {
                    this.StackRules = data.StackRules;
                }
                if ("Targets" in data && data.Targets != undefined) {
                    this.Targets = data.Targets;
                }
                if ("Triggers" in data && data.Triggers != undefined) {
                    this.Triggers = data.Triggers;
                }
                if ("Effects" in data && data.Effects != undefined) {
                    this.Effects = data.Effects;
                }
            }
            if (!this.Targets)
                this.Targets = new Map();
            if (!this.Triggers)
                this.Triggers = new Map();
            if (!this.Effects)
                this.Effects = new Map();
        }
        get Stat() {
            return pb_1.Message.getFieldWithDefault(this, 1, dependency_2.entity.Stat.NoneStat) as dependency_2.entity.Stat;
        }
        set Stat(value: dependency_2.entity.Stat) {
            pb_1.Message.setField(this, 1, value);
        }
        get Amount() {
            return pb_1.Message.getWrapperField(this, Amount, 2) as Amount;
        }
        set Amount(value: Amount) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_Amount() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get Duration() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set Duration(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get Icon() {
            return pb_1.Message.getFieldWithDefault(this, 5, new Uint8Array(0)) as Uint8Array;
        }
        set Icon(value: Uint8Array) {
            pb_1.Message.setField(this, 5, value);
        }
        get Delay() {
            return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
        }
        set Delay(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        get Repeat() {
            return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
        }
        set Repeat(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        get StackRules() {
            return pb_1.Message.getWrapperField(this, StackRules, 8) as StackRules;
        }
        set StackRules(value: StackRules) {
            pb_1.Message.setWrapperField(this, 8, value);
        }
        get has_StackRules() {
            return pb_1.Message.getField(this, 8) != null;
        }
        get Targets() {
            return pb_1.Message.getField(this, 9) as any as Map<string, Target>;
        }
        set Targets(value: Map<string, Target>) {
            pb_1.Message.setField(this, 9, value as any);
        }
        get Triggers() {
            return pb_1.Message.getField(this, 10) as any as Map<string, Trigger>;
        }
        set Triggers(value: Map<string, Trigger>) {
            pb_1.Message.setField(this, 10, value as any);
        }
        get Effects() {
            return pb_1.Message.getField(this, 11) as any as Map<string, Effect>;
        }
        set Effects(value: Map<string, Effect>) {
            pb_1.Message.setField(this, 11, value as any);
        }
        static fromObject(data: {
            Stat?: dependency_2.entity.Stat;
            Amount?: ReturnType<typeof Amount.prototype.toObject>;
            Duration?: number;
            Icon?: Uint8Array;
            Delay?: number;
            Repeat?: number;
            StackRules?: ReturnType<typeof StackRules.prototype.toObject>;
            Targets?: {
                [key: string]: ReturnType<typeof Target.prototype.toObject>;
            };
            Triggers?: {
                [key: string]: ReturnType<typeof Trigger.prototype.toObject>;
            };
            Effects?: {
                [key: string]: ReturnType<typeof Effect.prototype.toObject>;
            };
        }): Effect {
            const message = new Effect({});
            if (data.Stat != null) {
                message.Stat = data.Stat;
            }
            if (data.Amount != null) {
                message.Amount = Amount.fromObject(data.Amount);
            }
            if (data.Duration != null) {
                message.Duration = data.Duration;
            }
            if (data.Icon != null) {
                message.Icon = data.Icon;
            }
            if (data.Delay != null) {
                message.Delay = data.Delay;
            }
            if (data.Repeat != null) {
                message.Repeat = data.Repeat;
            }
            if (data.StackRules != null) {
                message.StackRules = StackRules.fromObject(data.StackRules);
            }
            if (typeof data.Targets == "object") {
                message.Targets = new Map(Object.entries(data.Targets).map(([key, value]) => [key, Target.fromObject(value)]));
            }
            if (typeof data.Triggers == "object") {
                message.Triggers = new Map(Object.entries(data.Triggers).map(([key, value]) => [key, Trigger.fromObject(value)]));
            }
            if (typeof data.Effects == "object") {
                message.Effects = new Map(Object.entries(data.Effects).map(([key, value]) => [key, Effect.fromObject(value)]));
            }
            return message;
        }
        toObject() {
            const data: {
                Stat?: dependency_2.entity.Stat;
                Amount?: ReturnType<typeof Amount.prototype.toObject>;
                Duration?: number;
                Icon?: Uint8Array;
                Delay?: number;
                Repeat?: number;
                StackRules?: ReturnType<typeof StackRules.prototype.toObject>;
                Targets?: {
                    [key: string]: ReturnType<typeof Target.prototype.toObject>;
                };
                Triggers?: {
                    [key: string]: ReturnType<typeof Trigger.prototype.toObject>;
                };
                Effects?: {
                    [key: string]: ReturnType<typeof Effect.prototype.toObject>;
                };
            } = {};
            if (this.Stat != null) {
                data.Stat = this.Stat;
            }
            if (this.Amount != null) {
                data.Amount = this.Amount.toObject();
            }
            if (this.Duration != null) {
                data.Duration = this.Duration;
            }
            if (this.Icon != null) {
                data.Icon = this.Icon;
            }
            if (this.Delay != null) {
                data.Delay = this.Delay;
            }
            if (this.Repeat != null) {
                data.Repeat = this.Repeat;
            }
            if (this.StackRules != null) {
                data.StackRules = this.StackRules.toObject();
            }
            if (this.Targets != null) {
                data.Targets = (Object.fromEntries)((Array.from)(this.Targets).map(([key, value]) => [key, value.toObject()]));
            }
            if (this.Triggers != null) {
                data.Triggers = (Object.fromEntries)((Array.from)(this.Triggers).map(([key, value]) => [key, value.toObject()]));
            }
            if (this.Effects != null) {
                data.Effects = (Object.fromEntries)((Array.from)(this.Effects).map(([key, value]) => [key, value.toObject()]));
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Stat != dependency_2.entity.Stat.NoneStat)
                writer.writeEnum(1, this.Stat);
            if (this.has_Amount)
                writer.writeMessage(2, this.Amount, () => this.Amount.serialize(writer));
            if (this.Duration != 0)
                writer.writeInt64(4, this.Duration);
            if (this.Icon.length)
                writer.writeBytes(5, this.Icon);
            if (this.Delay != 0)
                writer.writeInt64(6, this.Delay);
            if (this.Repeat != 0)
                writer.writeInt64(7, this.Repeat);
            if (this.has_StackRules)
                writer.writeMessage(8, this.StackRules, () => this.StackRules.serialize(writer));
            for (const [key, value] of this.Targets) {
                writer.writeMessage(9, this.Targets, () => {
                    writer.writeString(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            for (const [key, value] of this.Triggers) {
                writer.writeMessage(10, this.Triggers, () => {
                    writer.writeString(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            for (const [key, value] of this.Effects) {
                writer.writeMessage(11, this.Effects, () => {
                    writer.writeString(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Effect {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Effect();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.Stat = reader.readEnum();
                        break;
                    case 2:
                        reader.readMessage(message.Amount, () => message.Amount = Amount.deserialize(reader));
                        break;
                    case 4:
                        message.Duration = reader.readInt64();
                        break;
                    case 5:
                        message.Icon = reader.readBytes();
                        break;
                    case 6:
                        message.Delay = reader.readInt64();
                        break;
                    case 7:
                        message.Repeat = reader.readInt64();
                        break;
                    case 8:
                        reader.readMessage(message.StackRules, () => message.StackRules = StackRules.deserialize(reader));
                        break;
                    case 9:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.Targets as any, reader, reader.readString, () => {
                            let value;
                            reader.readMessage(message, () => value = Target.deserialize(reader));
                            return value;
                        }));
                        break;
                    case 10:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.Triggers as any, reader, reader.readString, () => {
                            let value;
                            reader.readMessage(message, () => value = Trigger.deserialize(reader));
                            return value;
                        }));
                        break;
                    case 11:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.Effects as any, reader, reader.readString, () => {
                            let value;
                            reader.readMessage(message, () => value = Effect.deserialize(reader));
                            return value;
                        }));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Effect {
            return Effect.deserialize(bytes);
        }
    }
    export class A extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            ID?: Uint8Array;
            Name?: string;
            Icon?: Uint8Array;
            Animation?: Uint8Array;
            CastTime?: number;
            ManaCost?: number;
            Cooldown?: number;
            Effects?: Map<string, Effect>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("ID" in data && data.ID != undefined) {
                    this.ID = data.ID;
                }
                if ("Name" in data && data.Name != undefined) {
                    this.Name = data.Name;
                }
                if ("Icon" in data && data.Icon != undefined) {
                    this.Icon = data.Icon;
                }
                if ("Animation" in data && data.Animation != undefined) {
                    this.Animation = data.Animation;
                }
                if ("CastTime" in data && data.CastTime != undefined) {
                    this.CastTime = data.CastTime;
                }
                if ("ManaCost" in data && data.ManaCost != undefined) {
                    this.ManaCost = data.ManaCost;
                }
                if ("Cooldown" in data && data.Cooldown != undefined) {
                    this.Cooldown = data.Cooldown;
                }
                if ("Effects" in data && data.Effects != undefined) {
                    this.Effects = data.Effects;
                }
            }
            if (!this.Effects)
                this.Effects = new Map();
        }
        get ID() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set ID(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        get Name() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set Name(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get Icon() {
            return pb_1.Message.getFieldWithDefault(this, 3, new Uint8Array(0)) as Uint8Array;
        }
        set Icon(value: Uint8Array) {
            pb_1.Message.setField(this, 3, value);
        }
        get Animation() {
            return pb_1.Message.getFieldWithDefault(this, 4, new Uint8Array(0)) as Uint8Array;
        }
        set Animation(value: Uint8Array) {
            pb_1.Message.setField(this, 4, value);
        }
        get CastTime() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set CastTime(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get ManaCost() {
            return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
        }
        set ManaCost(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        get Cooldown() {
            return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
        }
        set Cooldown(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        get Effects() {
            return pb_1.Message.getField(this, 8) as any as Map<string, Effect>;
        }
        set Effects(value: Map<string, Effect>) {
            pb_1.Message.setField(this, 8, value as any);
        }
        static fromObject(data: {
            ID?: Uint8Array;
            Name?: string;
            Icon?: Uint8Array;
            Animation?: Uint8Array;
            CastTime?: number;
            ManaCost?: number;
            Cooldown?: number;
            Effects?: {
                [key: string]: ReturnType<typeof Effect.prototype.toObject>;
            };
        }): A {
            const message = new A({});
            if (data.ID != null) {
                message.ID = data.ID;
            }
            if (data.Name != null) {
                message.Name = data.Name;
            }
            if (data.Icon != null) {
                message.Icon = data.Icon;
            }
            if (data.Animation != null) {
                message.Animation = data.Animation;
            }
            if (data.CastTime != null) {
                message.CastTime = data.CastTime;
            }
            if (data.ManaCost != null) {
                message.ManaCost = data.ManaCost;
            }
            if (data.Cooldown != null) {
                message.Cooldown = data.Cooldown;
            }
            if (typeof data.Effects == "object") {
                message.Effects = new Map(Object.entries(data.Effects).map(([key, value]) => [key, Effect.fromObject(value)]));
            }
            return message;
        }
        toObject() {
            const data: {
                ID?: Uint8Array;
                Name?: string;
                Icon?: Uint8Array;
                Animation?: Uint8Array;
                CastTime?: number;
                ManaCost?: number;
                Cooldown?: number;
                Effects?: {
                    [key: string]: ReturnType<typeof Effect.prototype.toObject>;
                };
            } = {};
            if (this.ID != null) {
                data.ID = this.ID;
            }
            if (this.Name != null) {
                data.Name = this.Name;
            }
            if (this.Icon != null) {
                data.Icon = this.Icon;
            }
            if (this.Animation != null) {
                data.Animation = this.Animation;
            }
            if (this.CastTime != null) {
                data.CastTime = this.CastTime;
            }
            if (this.ManaCost != null) {
                data.ManaCost = this.ManaCost;
            }
            if (this.Cooldown != null) {
                data.Cooldown = this.Cooldown;
            }
            if (this.Effects != null) {
                data.Effects = (Object.fromEntries)((Array.from)(this.Effects).map(([key, value]) => [key, value.toObject()]));
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.ID.length)
                writer.writeBytes(1, this.ID);
            if (this.Name.length)
                writer.writeString(2, this.Name);
            if (this.Icon.length)
                writer.writeBytes(3, this.Icon);
            if (this.Animation.length)
                writer.writeBytes(4, this.Animation);
            if (this.CastTime != 0)
                writer.writeInt64(5, this.CastTime);
            if (this.ManaCost != 0)
                writer.writeInt64(6, this.ManaCost);
            if (this.Cooldown != 0)
                writer.writeInt64(7, this.Cooldown);
            for (const [key, value] of this.Effects) {
                writer.writeMessage(8, this.Effects, () => {
                    writer.writeString(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): A {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new A();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.ID = reader.readBytes();
                        break;
                    case 2:
                        message.Name = reader.readString();
                        break;
                    case 3:
                        message.Icon = reader.readBytes();
                        break;
                    case 4:
                        message.Animation = reader.readBytes();
                        break;
                    case 5:
                        message.CastTime = reader.readInt64();
                        break;
                    case 6:
                        message.ManaCost = reader.readInt64();
                        break;
                    case 7:
                        message.Cooldown = reader.readInt64();
                        break;
                    case 8:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.Effects as any, reader, reader.readString, () => {
                            let value;
                            reader.readMessage(message, () => value = Effect.deserialize(reader));
                            return value;
                        }));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): A {
            return A.deserialize(bytes);
        }
    }
}
